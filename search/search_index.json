{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kubernetes-Playground Handbook The Kubernetes-Playground is a solution to setup a simple Kubernetes-Cluster with minimal effort, to learn and play with Kubernetes. Prerequisites The usages of the Kubernetes-Playground requires the installation of the following software on the host: Virtualbox Vagrant Ansible Project layout . # Project root \u251c\u2500\u2500 .github # the github workflow files \u251c\u2500\u2500 bin # project specific binaries, like plantuml.jar; excluded from version control \u251c\u2500\u2500 docs # documentation \u251c\u2500\u2500 kubernetes-setup # Ansible scripts to provision the vagrant box \u251c\u2500\u2500 mkdocs.yml # configuration file for mkdocs \u251c\u2500\u2500 README.md # Readme file for github \u2514\u2500\u2500 Vagrantfile # Configuration of the vagrant box","title":"Home"},{"location":"#kubernetes-playground-handbook","text":"The Kubernetes-Playground is a solution to setup a simple Kubernetes-Cluster with minimal effort, to learn and play with Kubernetes.","title":"Kubernetes-Playground Handbook"},{"location":"#prerequisites","text":"The usages of the Kubernetes-Playground requires the installation of the following software on the host: Virtualbox Vagrant Ansible","title":"Prerequisites"},{"location":"#project-layout","text":". # Project root \u251c\u2500\u2500 .github # the github workflow files \u251c\u2500\u2500 bin # project specific binaries, like plantuml.jar; excluded from version control \u251c\u2500\u2500 docs # documentation \u251c\u2500\u2500 kubernetes-setup # Ansible scripts to provision the vagrant box \u251c\u2500\u2500 mkdocs.yml # configuration file for mkdocs \u251c\u2500\u2500 README.md # Readme file for github \u2514\u2500\u2500 Vagrantfile # Configuration of the vagrant box","title":"Project layout"},{"location":"documentation-guide/","text":"Documentation Guide Mkdocs and PlantUML is used to generate the Handbook of this project. It is helpful to install mkdocs to generate a searchable html version of this handbook. Mkdocs Commands # Create a new project. mkdocs new [dir-name] # Start the live-reloading docs server. mkdocs serve # Build the documentation site. mkdocs build # Print this help message. mkdocs help PlantUML PlantUML is a tool to create diagrams from plain text files must be placed in the folder docs/diagrams as a suffix for PlantUML files, .plantuml is used this is required for the Makefile, to create image on the local machine and the GitHub Action to build and deploy the GitHub Page of this project The Visual Studio Code plugin, provides code highlighting, code completion and a live preview, ... Example Diagram Makefile The Makefile to create png or svg images from plain text is in the docs folder it is just needed for local development In the case that plantuml is not in the bin folder of this project, it will be automatically downloaded Overview Targets Target Description all Build png and svg images png Build png images svg Build svg images clean Delete all png and svg images URLs https://plantuml.com/ https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml","title":"Documentation"},{"location":"documentation-guide/#documentation-guide","text":"Mkdocs and PlantUML is used to generate the Handbook of this project. It is helpful to install mkdocs to generate a searchable html version of this handbook.","title":"Documentation Guide"},{"location":"documentation-guide/#mkdocs-commands","text":"# Create a new project. mkdocs new [dir-name] # Start the live-reloading docs server. mkdocs serve # Build the documentation site. mkdocs build # Print this help message. mkdocs help","title":"Mkdocs Commands"},{"location":"documentation-guide/#plantuml","text":"PlantUML is a tool to create diagrams from plain text files must be placed in the folder docs/diagrams as a suffix for PlantUML files, .plantuml is used this is required for the Makefile, to create image on the local machine and the GitHub Action to build and deploy the GitHub Page of this project The Visual Studio Code plugin, provides code highlighting, code completion and a live preview, ...","title":"PlantUML"},{"location":"documentation-guide/#example-diagram","text":"","title":"Example Diagram"},{"location":"documentation-guide/#makefile","text":"The Makefile to create png or svg images from plain text is in the docs folder it is just needed for local development In the case that plantuml is not in the bin folder of this project, it will be automatically downloaded","title":"Makefile"},{"location":"documentation-guide/#overview-targets","text":"Target Description all Build png and svg images png Build png images svg Build svg images clean Delete all png and svg images","title":"Overview Targets"},{"location":"documentation-guide/#urls","text":"https://plantuml.com/ https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml","title":"URLs"},{"location":"installation/","text":"Installation Guide The Kubernetes-Playground is build and tested on Ubuntu 20.04. Hence, the described steps are focusing on Ubuntu. It should be possible to use any Operation system as a host. Required Before starting to use this project, make sure that the following software is installed on the system: Virtualbox Vagrant Ansible apt install virtualbox vagrant ansible Optional - Documentation To generate a searchable HTML documentation mkdocs must be installed on the system # Install mkdocs sudo apt install mkdocs # Install pip sudo apt install python3-pip # Make sure latest version is used pip3 install --upgrade mkdocs Plantuml By the first use of he makefile in the docs folder, plantuml is downloaded For some diagrams plantuml depends on graphviz. Hence, it must be installed. # Install graphviz sudo apt install graphviz","title":"Installation"},{"location":"installation/#installation-guide","text":"The Kubernetes-Playground is build and tested on Ubuntu 20.04. Hence, the described steps are focusing on Ubuntu. It should be possible to use any Operation system as a host.","title":"Installation Guide"},{"location":"installation/#required","text":"Before starting to use this project, make sure that the following software is installed on the system: Virtualbox Vagrant Ansible apt install virtualbox vagrant ansible","title":"Required"},{"location":"installation/#optional-documentation","text":"To generate a searchable HTML documentation mkdocs must be installed on the system # Install mkdocs sudo apt install mkdocs # Install pip sudo apt install python3-pip # Make sure latest version is used pip3 install --upgrade mkdocs","title":"Optional - Documentation"},{"location":"installation/#plantuml","text":"By the first use of he makefile in the docs folder, plantuml is downloaded For some diagrams plantuml depends on graphviz. Hence, it must be installed. # Install graphviz sudo apt install graphviz","title":"Plantuml"},{"location":"kubectl-config/","text":"Configuration of kubectl The next bash snippets outlines, the installation and configuration to use kubectl to access microk8s in a vagrant box. Install kubectl # Install kubectl via snap sudo snap install kubectl --classic kubectl configuration # Create the configuration folder in the home path mkdir .kube # get the configuration from the vagrant box # if the config file already exist, it is needed to merege them vagrant ssh -c microk8s.config >> ~/.kube/config # change the server ip to the external ip of the vagrant box vi ~/.kube/config bash bash-completion sudo kubectl completion bash >/etc/bash_completion.d/kubectl","title":"Kubectl"},{"location":"kubectl-config/#configuration-of-kubectl","text":"The next bash snippets outlines, the installation and configuration to use kubectl to access microk8s in a vagrant box.","title":"Configuration of kubectl"},{"location":"kubectl-config/#install-kubectl","text":"# Install kubectl via snap sudo snap install kubectl --classic","title":"Install kubectl"},{"location":"kubectl-config/#kubectl-configuration","text":"# Create the configuration folder in the home path mkdir .kube # get the configuration from the vagrant box # if the config file already exist, it is needed to merege them vagrant ssh -c microk8s.config >> ~/.kube/config # change the server ip to the external ip of the vagrant box vi ~/.kube/config","title":"kubectl configuration"},{"location":"kubectl-config/#bash-bash-completion","text":"sudo kubectl completion bash >/etc/bash_completion.d/kubectl","title":"bash bash-completion"},{"location":"vagrant/","text":"Vagrant Vagrant is an open-source software to automate the provision of virtual machine. For this playground, it is used to rapidly setup a Ubuntu guest system within VirtualBox. Commands This sections covers the most important commands to use vagrant for more information use vagrant --help or man vagrant # starts and provisions the vagrant environment vagrant up # stops the vagrant environment vagrant halt # login via ssh vagrant ssh # provisions to a running vagrant machine; useful by a change of the ansible scripts vagrant provision # stops and deletes the vagrant machine vagrant destroy URLs About Vagrant","title":"Vagrant"},{"location":"vagrant/#vagrant","text":"Vagrant is an open-source software to automate the provision of virtual machine. For this playground, it is used to rapidly setup a Ubuntu guest system within VirtualBox.","title":"Vagrant"},{"location":"vagrant/#commands","text":"This sections covers the most important commands to use vagrant for more information use vagrant --help or man vagrant # starts and provisions the vagrant environment vagrant up # stops the vagrant environment vagrant halt # login via ssh vagrant ssh # provisions to a running vagrant machine; useful by a change of the ansible scripts vagrant provision # stops and deletes the vagrant machine vagrant destroy","title":"Commands"},{"location":"vagrant/#urls","text":"About Vagrant","title":"URLs"},{"location":"k8s-apps/jenkins/","text":"Jenkins Operator This section will guide you through the process of installing Jenkins in the Kubernetes cluster. Enable DNS During the installation Jenkins will fetch updates, therefore DNS is needed. # Enable DNS vagrant ssh -c \"microk8s.enable dns\" Install Operator Configure Custom Resource Definition Create the custom resource definition for the jenkins operator # Apply the custom resource definition kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/crds/jenkins_v1alpha2_jenkins_crd.yaml # Get all custom resource definition - there should be two custom resource definition: # - jenkins.jenkins.io # - jenkinsimages.jenkins.io kubectl get customresourcedefinitions.apiextensions.k8s.io # Delete the custom resource definition kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkins.jenkins.io kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkinsimages.jenkins.io Deploy Operator - using yaml Create the Operator in the default namespace kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/all-in-one-v1alpha2.yaml In the default namespace should be a pod running with the name jenkins-operator-* . This can be checked with: kubectl get pods --all-namespaces Deploy Jenkins kubectl apply -f k8s-apps/jenkins/jenkins_instance.yaml After a while a jenkins pod should be running watch kubectl get pods In the case that the jenkins pod is in a restarting loop, check if DNS is enabled. # Connect to the vagrant box vagrant ssh # Check the status - dns should be listed by the enabled addons microk8s.status # or as a one liner vagrant ssh -c \"microk8s.status\" Credentials The postfix *- my-jenkins , must be same as in the jenkins_instance.yaml in the section metadata.name # The user Name of the Jenkins instance echo \"User:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.user}' | base64 -d | xargs echo echo \"Password:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.password}' | base64 -d | xargs echo Access the Jenkins By default Kubernetes is not routing traffic to any pods. It is possible to route your local traffic to Kubernetes by creating a port-forward # Create a port-forwarding from local host to the kubectl port-forward jenkins-my-jenkins 8080:8080 After executing this command, it is possible to open the URL http://127.0.0.1:8080 and login to Jenkins. URLs https://jenkinsci.github.io/kubernetes-operator/docs/ https://github.com/jenkinsci/kubernetes-operator The files (such as custom resource definition), are in the deploy folder","title":"Jenkins"},{"location":"k8s-apps/jenkins/#jenkins-operator","text":"This section will guide you through the process of installing Jenkins in the Kubernetes cluster.","title":"Jenkins Operator"},{"location":"k8s-apps/jenkins/#enable-dns","text":"During the installation Jenkins will fetch updates, therefore DNS is needed. # Enable DNS vagrant ssh -c \"microk8s.enable dns\"","title":"Enable DNS"},{"location":"k8s-apps/jenkins/#install-operator","text":"","title":"Install Operator"},{"location":"k8s-apps/jenkins/#configure-custom-resource-definition","text":"Create the custom resource definition for the jenkins operator # Apply the custom resource definition kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/crds/jenkins_v1alpha2_jenkins_crd.yaml # Get all custom resource definition - there should be two custom resource definition: # - jenkins.jenkins.io # - jenkinsimages.jenkins.io kubectl get customresourcedefinitions.apiextensions.k8s.io # Delete the custom resource definition kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkins.jenkins.io kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkinsimages.jenkins.io","title":"Configure Custom Resource Definition"},{"location":"k8s-apps/jenkins/#deploy-operator-using-yaml","text":"Create the Operator in the default namespace kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/all-in-one-v1alpha2.yaml In the default namespace should be a pod running with the name jenkins-operator-* . This can be checked with: kubectl get pods --all-namespaces","title":"Deploy Operator - using yaml"},{"location":"k8s-apps/jenkins/#deploy-jenkins","text":"kubectl apply -f k8s-apps/jenkins/jenkins_instance.yaml After a while a jenkins pod should be running watch kubectl get pods In the case that the jenkins pod is in a restarting loop, check if DNS is enabled. # Connect to the vagrant box vagrant ssh # Check the status - dns should be listed by the enabled addons microk8s.status # or as a one liner vagrant ssh -c \"microk8s.status\"","title":"Deploy Jenkins"},{"location":"k8s-apps/jenkins/#credentials","text":"The postfix *- my-jenkins , must be same as in the jenkins_instance.yaml in the section metadata.name # The user Name of the Jenkins instance echo \"User:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.user}' | base64 -d | xargs echo echo \"Password:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.password}' | base64 -d | xargs echo","title":"Credentials"},{"location":"k8s-apps/jenkins/#access-the-jenkins","text":"By default Kubernetes is not routing traffic to any pods. It is possible to route your local traffic to Kubernetes by creating a port-forward # Create a port-forwarding from local host to the kubectl port-forward jenkins-my-jenkins 8080:8080 After executing this command, it is possible to open the URL http://127.0.0.1:8080 and login to Jenkins.","title":"Access the Jenkins"},{"location":"k8s-apps/jenkins/#urls","text":"https://jenkinsci.github.io/kubernetes-operator/docs/ https://github.com/jenkinsci/kubernetes-operator The files (such as custom resource definition), are in the deploy folder","title":"URLs"},{"location":"k8s-apps/nginx/","text":"Ngnix Deployment Diagram Deploy Ngnix # Creates the deployment and rollout three nginx instances kubectl apply -f k8s-apps/nginx/nginx-deployment.yaml # Create a service which will route the traffic to one of the three nginx pods kubectl apply -f k8s-apps/nginx/nginx-service.yaml # Create a port-forwarding from local host to the service kubectl port-forward service/my-ngnix-service 8080:8080 # Enable a Ingress controller vagrant ssh -c \"microk8s.enable ingress\" # Create a ingress kubectl apply -f k8s-apps/nginx/nginx-ingress.yaml The nginx is now reachable from outside the cluster, to test it open http://192.168.60.10/path-of-my-ingress in a Browser. URLs https://kubernetes.io/docs/concepts/workloads/controllers/deployment/ https://kubernetes.io/docs/concepts/services-networking/service/ https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/ https://kubernetes.io/docs/concepts/services-networking/ingress/","title":"Nginx"},{"location":"k8s-apps/nginx/#ngnix","text":"","title":"Ngnix"},{"location":"k8s-apps/nginx/#deployment-diagram","text":"","title":"Deployment Diagram"},{"location":"k8s-apps/nginx/#deploy-ngnix","text":"# Creates the deployment and rollout three nginx instances kubectl apply -f k8s-apps/nginx/nginx-deployment.yaml # Create a service which will route the traffic to one of the three nginx pods kubectl apply -f k8s-apps/nginx/nginx-service.yaml # Create a port-forwarding from local host to the service kubectl port-forward service/my-ngnix-service 8080:8080 # Enable a Ingress controller vagrant ssh -c \"microk8s.enable ingress\" # Create a ingress kubectl apply -f k8s-apps/nginx/nginx-ingress.yaml The nginx is now reachable from outside the cluster, to test it open http://192.168.60.10/path-of-my-ingress in a Browser.","title":"Deploy Ngnix"},{"location":"k8s-apps/nginx/#urls","text":"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/ https://kubernetes.io/docs/concepts/services-networking/service/ https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/ https://kubernetes.io/docs/concepts/services-networking/ingress/","title":"URLs"}]}