{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kubernetes-Playground Handbook The Kubernetes-Playground is a solution to setup a simple Kubernetes-Cluster with minimal effort, to learn and play with Kubernetes. Prerequisites The usages of the Kubernetes-Playground requires the installation of the following software on the host: Virtualbox Vagrant Ansible Project layout . # Project root \u251c\u2500\u2500 docs # documentation \u251c\u2500\u2500 kubernetes-setup # Ansible scripts to provision the vagrant box \u251c\u2500\u2500 mkdocs.yml # configuration file for mkdocs \u251c\u2500\u2500 README.md # Readme file for github \u2514\u2500\u2500 Vagrantfile # Configuration of the vagrant box","title":"Home"},{"location":"#kubernetes-playground-handbook","text":"The Kubernetes-Playground is a solution to setup a simple Kubernetes-Cluster with minimal effort, to learn and play with Kubernetes.","title":"Kubernetes-Playground Handbook"},{"location":"#prerequisites","text":"The usages of the Kubernetes-Playground requires the installation of the following software on the host: Virtualbox Vagrant Ansible","title":"Prerequisites"},{"location":"#project-layout","text":". # Project root \u251c\u2500\u2500 docs # documentation \u251c\u2500\u2500 kubernetes-setup # Ansible scripts to provision the vagrant box \u251c\u2500\u2500 mkdocs.yml # configuration file for mkdocs \u251c\u2500\u2500 README.md # Readme file for github \u2514\u2500\u2500 Vagrantfile # Configuration of the vagrant box","title":"Project layout"},{"location":"installation/","text":"Installation Guide The Kubernetes-Playground is build and tested on Ubuntu 20.04. Hence, the described steps are focusing on Ubuntu. It should be possible to use any Operation system as a host. Required Before starting to use this project, make sure that the following software is installed on the system: Virtualbox Vagrant Ansible apt install virtualbox vagrant ansible Optional - Documentation To generate a searchable HTML documentation mkdocs must be installed on the system # Install mkdocs sudo apt install mkdocs # Install pip sudo apt install python3-pip # Make sure latest version is used pip3 install --upgrade mkdocs","title":"Installation"},{"location":"installation/#installation-guide","text":"The Kubernetes-Playground is build and tested on Ubuntu 20.04. Hence, the described steps are focusing on Ubuntu. It should be possible to use any Operation system as a host.","title":"Installation Guide"},{"location":"installation/#required","text":"Before starting to use this project, make sure that the following software is installed on the system: Virtualbox Vagrant Ansible apt install virtualbox vagrant ansible","title":"Required"},{"location":"installation/#optional-documentation","text":"To generate a searchable HTML documentation mkdocs must be installed on the system # Install mkdocs sudo apt install mkdocs # Install pip sudo apt install python3-pip # Make sure latest version is used pip3 install --upgrade mkdocs","title":"Optional - Documentation"},{"location":"kubectl-config/","text":"Configuration of kubectl The next bash snippets outlines, the installation and configuration to use kubectl to access microk8s in a vagrant box. Install kubectl # Install kubectl via snap sudo snap install kubectl --classic kubectl configuration # Create the configuration folder in the home path mkdir .kube # get the configuration from the vagrant box # if the config file already exist, it is needed to merege them vagrant ssh -c microk8s.config >> ~/.kube/config # change the server ip to the external ip of the vagrant box vi ~/.kube/config bash bash-completion sudo kubectl completion bash >/etc/bash_completion.d/kubectl","title":"Kubectl"},{"location":"kubectl-config/#configuration-of-kubectl","text":"The next bash snippets outlines, the installation and configuration to use kubectl to access microk8s in a vagrant box.","title":"Configuration of kubectl"},{"location":"kubectl-config/#install-kubectl","text":"# Install kubectl via snap sudo snap install kubectl --classic","title":"Install kubectl"},{"location":"kubectl-config/#kubectl-configuration","text":"# Create the configuration folder in the home path mkdir .kube # get the configuration from the vagrant box # if the config file already exist, it is needed to merege them vagrant ssh -c microk8s.config >> ~/.kube/config # change the server ip to the external ip of the vagrant box vi ~/.kube/config","title":"kubectl configuration"},{"location":"kubectl-config/#bash-bash-completion","text":"sudo kubectl completion bash >/etc/bash_completion.d/kubectl","title":"bash bash-completion"},{"location":"mkdocs-guide/","text":"Mkdocs Guide Mkdocs is used to generate the Handbook for this project. It is helpful to install mkdocs to generate a searchable html version of this handbook. Plantuml Commands # Create a new project. mkdocs new [dir-name] # Start the live-reloading docs server. mkdocs serve # Build the documentation site. mkdocs build # Print this help message. mkdocs help","title":"Mkdocs"},{"location":"mkdocs-guide/#mkdocs-guide","text":"Mkdocs is used to generate the Handbook for this project. It is helpful to install mkdocs to generate a searchable html version of this handbook.","title":"Mkdocs Guide"},{"location":"mkdocs-guide/#plantuml","text":"","title":"Plantuml"},{"location":"mkdocs-guide/#commands","text":"# Create a new project. mkdocs new [dir-name] # Start the live-reloading docs server. mkdocs serve # Build the documentation site. mkdocs build # Print this help message. mkdocs help","title":"Commands"},{"location":"vagrant/","text":"Vagrant Vagrant is an open-source software to automate the provision of virtual machine. For this playground, it is used to rapidly setup a Ubuntu guest system within VirtualBox. Commands This sections covers the most important commands to use vagrant for more information use vagrant --help or man vagrant # starts and provisions the vagrant environment vagrant up # stops the vagrant environment vagrant halt # login via ssh vagrant ssh # provisions to a running vagrant machine; useful by a change of the ansible scripts vagrant provision # stops and deletes the vagrant machine vagrant destroy URLs About Vagrant","title":"Vagrant"},{"location":"vagrant/#vagrant","text":"Vagrant is an open-source software to automate the provision of virtual machine. For this playground, it is used to rapidly setup a Ubuntu guest system within VirtualBox.","title":"Vagrant"},{"location":"vagrant/#commands","text":"This sections covers the most important commands to use vagrant for more information use vagrant --help or man vagrant # starts and provisions the vagrant environment vagrant up # stops the vagrant environment vagrant halt # login via ssh vagrant ssh # provisions to a running vagrant machine; useful by a change of the ansible scripts vagrant provision # stops and deletes the vagrant machine vagrant destroy","title":"Commands"},{"location":"vagrant/#urls","text":"About Vagrant","title":"URLs"},{"location":"operators/jenkins/","text":"Jenkins Operator This section will guide you through the process of installing Jenkins in the Kubernetes cluster. Enable DNS During the installation Jenkins will fetch updates, therefore DNS is needed. # Enable DNS vagrant ssh -c \"microk8s.enable dns\" Install Operator Configure Custom Resource Definition Create the custom resource definition for the jenkins operator # Apply the custom resource definition kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/crds/jenkins_v1alpha2_jenkins_crd.yaml # Get all custom resource definition - there should be two custom resource definition: # - jenkins.jenkins.io # - jenkinsimages.jenkins.io kubectl get customresourcedefinitions.apiextensions.k8s.io # Delete the custom resource definition kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkins.jenkins.io kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkinsimages.jenkins.io Deploy Operator - using yaml Create the Operator in the default namespace kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/all-in-one-v1alpha2.yaml In the default namespace should be a pod running with the name jenkins-operator-* . This can be checked with: kubectl get pods --all-namespaces Deploy Jenkins kubectl apply -f operators/jenkins/jenkins_instance.yaml After a while a jenkins pod should be running watch kubectl get pods In the case that the jenkins pod is in a restarting loop, check if DNS is enabled. # Connect to the vagrant box vagrant ssh # Check the status - dns should be listed by the enabled addons microk8s.status # or as a one liner vagrant ssh -c \"microk8s.status\" Credentials The postfix *- my-jenkins , must be same as in the jenkins_instance.yaml in the section metadata.name # The user Name of the Jenkins instance echo \"User:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.user}' | base64 -d | xargs echo echo \"Password:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.password}' | base64 -d | xargs echo Access the Jenkins By default Kubernetes is not routing traffic to any pods. It is possible to route your local traffic to Kubernetes by creating a port-forward # Create a port-forwarding from local host to the kubectl port-forward jenkins-my-jenkins 8080:8080 After executing this command, it is possible to open the URL http://127.0.0.1:8080 and login to Jenkins. URLs https://jenkinsci.github.io/kubernetes-operator/docs/ https://github.com/jenkinsci/kubernetes-operator The files (such as custom resource definition), are in the deploy folder","title":"Jenkins"},{"location":"operators/jenkins/#jenkins-operator","text":"This section will guide you through the process of installing Jenkins in the Kubernetes cluster.","title":"Jenkins Operator"},{"location":"operators/jenkins/#enable-dns","text":"During the installation Jenkins will fetch updates, therefore DNS is needed. # Enable DNS vagrant ssh -c \"microk8s.enable dns\"","title":"Enable DNS"},{"location":"operators/jenkins/#install-operator","text":"","title":"Install Operator"},{"location":"operators/jenkins/#configure-custom-resource-definition","text":"Create the custom resource definition for the jenkins operator # Apply the custom resource definition kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/crds/jenkins_v1alpha2_jenkins_crd.yaml # Get all custom resource definition - there should be two custom resource definition: # - jenkins.jenkins.io # - jenkinsimages.jenkins.io kubectl get customresourcedefinitions.apiextensions.k8s.io # Delete the custom resource definition kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkins.jenkins.io kubectl delete customresourcedefinitions.apiextensions.k8s.io jenkinsimages.jenkins.io","title":"Configure Custom Resource Definition"},{"location":"operators/jenkins/#deploy-operator-using-yaml","text":"Create the Operator in the default namespace kubectl apply -f https://raw.githubusercontent.com/jenkinsci/kubernetes-operator/master/deploy/all-in-one-v1alpha2.yaml In the default namespace should be a pod running with the name jenkins-operator-* . This can be checked with: kubectl get pods --all-namespaces","title":"Deploy Operator - using yaml"},{"location":"operators/jenkins/#deploy-jenkins","text":"kubectl apply -f operators/jenkins/jenkins_instance.yaml After a while a jenkins pod should be running watch kubectl get pods In the case that the jenkins pod is in a restarting loop, check if DNS is enabled. # Connect to the vagrant box vagrant ssh # Check the status - dns should be listed by the enabled addons microk8s.status # or as a one liner vagrant ssh -c \"microk8s.status\"","title":"Deploy Jenkins"},{"location":"operators/jenkins/#credentials","text":"The postfix *- my-jenkins , must be same as in the jenkins_instance.yaml in the section metadata.name # The user Name of the Jenkins instance echo \"User:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.user}' | base64 -d | xargs echo echo \"Password:\"; kubectl get secret jenkins-operator-credentials-my-jenkins -o 'jsonpath={.data.password}' | base64 -d | xargs echo","title":"Credentials"},{"location":"operators/jenkins/#access-the-jenkins","text":"By default Kubernetes is not routing traffic to any pods. It is possible to route your local traffic to Kubernetes by creating a port-forward # Create a port-forwarding from local host to the kubectl port-forward jenkins-my-jenkins 8080:8080 After executing this command, it is possible to open the URL http://127.0.0.1:8080 and login to Jenkins.","title":"Access the Jenkins"},{"location":"operators/jenkins/#urls","text":"https://jenkinsci.github.io/kubernetes-operator/docs/ https://github.com/jenkinsci/kubernetes-operator The files (such as custom resource definition), are in the deploy folder","title":"URLs"}]}